## 基本类型

每个基本类型都有对应的包装对象（Wrapper Object）

使用包装对象构造函数创建的值是对象类型，如果以普通函数的形式调用，则创建的是基本类型

对于基本类型，在访问属性或方法时，会自动转换为对应的包装对象，然后再访问

使用包装对象进行数学计算或拼接操作时，又会将其自动转换为对应的基本类型，然后再进行操作

这些转换操作都由编译器自动完成，这样就使基本类型也能像对象一样使用了

在一些面向对象的编程语言中，转换为对象的过程叫作装箱（Boxing），转换为基本类型的过程叫作拆箱（Unboxing）

## Math
### floor
向下取整，对小数而言，相当于舍弃小数部分

### ceil
向上取整，对小数而言，相当于整数部分+1

对整数而言，上述两个方法都返回整数本身

### round
四舍五入，如果是负数，且小数部分恰好是0.5，则会向整数方向进行四舍五入

即：正数且小数部分>=0.5则+1，负数且小数部分>0.5则+1

## Date
### 修改日期
所有获取日期的方法都有对应的修改方法，只需将get改为set即可，除了`getDay()`没有对应的`setDay()`方法

如果设置的日期部分溢出了，则会向上进1

通过`setTime()`可以把日期设置成时间戳所表示的时间

### 比较
日期之间可以互相比较，它们会先被转换成数字类型的时间戳再进行比较

## JSON
### 序列化

`JSON.stringify()`方法用于把JS对象转换成JSON格式的字符串，它最多可以接受3个参数

序列化过程中，有以下几点需要注意：
1. 如果属性的值是`undefined`，函数或`Symbol`类型，则这个属性会被忽略，但如果这些类型出现在数组中，则会替换成`null`
2. 如果属性的值是`BigInt`类型则会抛出`TypeError`异常
3. 如果属性的值有循环引用的对象则会抛出`TypeError`异常
4. 如果属性对象中有`toJSON()`方法，则会调用此方法转换成JSON字符串

`stringify()`方法的第2个参数用于定义 replacer（替换器），可以自定义序列化过程。它可以传入一个字符串数组或函数

如果传入一个字符串数组，那么它的含义是选择要包含在最终结果中的属性或元素，如果全部包括则可以传递`null`

如果传递一个函数，则表示对子对象中的每个属性都调用一次这个函数，函数接受`key`和`value`两个参数，需要返回JSON支持的类型的值。
如果返回`undefined`、函数、`Symbol`类型的值，则该属性不会包含在结果字符串中。如果返回的是对象，则会递归地调用该函数继续序列化。

注意：
1. replacer 函数在第1次执行时，`key`为空，`value`为对象本身
2. 如果对象有`toJSON()`方法，则它的值会在传递给 replacer 函数前先调用`toJSON()`方法

`stringify()`方法的第3个参数用于指定缩进，如果传递的是数字，则会缩进指定数量的空格，如果传递的是字符串，则会将该字符串作为缩进符号

注意：缩进数量不能大于10，字符串长度也不能大于10

### 反序列化
`JSON.parse()`方法用于把字符串格式的JSON数据转换为JS对象。

注意：任何一段合法的JSON数据都是合法的JS代码，所以在编写代码时尤其要注意，不要提供恶意代码注入的机会

和`stringify()`方法一样，`parse()`方法也可接受一个 reviver 函数，用于自定义反序列化过程

`stringify()`和`parse()`方法可以实现对象的深拷贝，但这种方式的性能较低

## Set
## WeakSet
和Rust中的 `Weak`结构体类似，`WeakSet`持有的是弱引用，添加到`WeakSet`中的对象不会增加强引用计数（strong count）
